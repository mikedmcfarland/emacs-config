#+STARTUP: showall indent
#+options: num:nil
#+BEGIN_HTML
---
title: Emacs Configuration
date: 2015-01-29
draft: false
tags : [linux]
---
#+END_HTML

#+TITLE: Emacs Configuration

* About
** This File
  This is an emacs org-mode file which generates my personal emacs
  configuration. These settings are used along side [[http://github.com/bbatsov/prelude][Emacs Prelude]]. I
  share my config across multiple machines and use git to version it.
  [[http://github.com/mikedmcfarland/emacs-config][Here is my configuration on github]].

** This  Emacs Config
  My workflow involves running mainly one window in a frame. And
  running many frames at once (all in daemon mode). Many settings are
  a consequence of this.

  *Why?*

  I run emacs in a [[http://i3wm.org][tiling window manager]], it takes care of tabing and
  window management needs. Its nicer when all my programs operate
  tabs/windowing consistently.

* Emacs initialization

** Personal Information
Set my name and email
  #+begin_src emacs-lisp
    (setq user-full-name "Mike McFarland"
          user-mail-address "mikedmcfarland@gmail.com")
  #+end_src

** Prelude Modules
   Prelude includes many packages you can toggle. Here's [[https://github.com/mikedmcfarland/emacs-config/blob/master/prelude-modules.el][the list]] I enabled.


** Packages
   My required packages, prelude will make sure these are downloaded
   and required at startup.
   #+begin_src emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/vendor/use-package")
     (require 'use-package)

     (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))

     (prelude-require-packages
      '(s
        monokai-theme
        restclient
        powerline-evil
        yasnippet
        multiple-cursors
        expand-region
        evil-nerd-commenter
        js2-refactor
        key-chord
        helm-swoop))
   #+end_src

** Backups
    store backups in one folder instead next to the file
    #+begin_src emacs-lisp
      (setq backup-directory-alist `(("." . "~/.emacs.d/.backups")))
    #+end_src

** Save Place
    Save cursor position when reopening a file
    #+begin_src emacs-lisp
      (setq save-place-file "~/.emacs.d/saveplace")
      (setq-default save-place t)
      (require 'saveplace)
    #+end_src

** Aesthetics
   Load the monokai theme (Sublime Text's default colors)
   #+begin_src emacs-lisp
     (load-theme 'monokai t)
   #+end_src

   Make sure we edit using visual lines, instead of actual line breaks.
   Helps when word wrapping is on.
   #+begin_src emacs-lisp
     (global-visual-line-mode t)
   #+end_src

   set the font, this seems to work for the emacs daemon, other methods
   were requiring me to re-run expressions after connecting another client
   #+begin_src emacs-lisp
     (add-to-list 'default-frame-alist '(font .   "Source Code Pro 12" ))
   #+end_src

   Add linenumbers
   #+begin_src emacs-lisp
     (setq linum-format "%3d ")
     (add-hook 'prog-mode-hook 'linum-mode)
   #+end_src


   A few miscallaneious things
   #+begin_src emacs-lisp
     (display-time-mode t)

     ;;smooth scrolling
     (setq scroll-margin 5
           scroll-conservatively 9999
           scroll-step 1)

    (defun set-my-margins()
      (setq left-margin-width 1)
      (setq right-margin-width 1))

    (add-hook 'text-mode-hook 'set-my-margins)
    (add-hook 'prog-mode-hook 'set-my-margins)

    (powerline-evil-vim-color-theme)
   #+end_src

*** TODO make margins dynamic
    currently we have static margins, it'd be nice to allow things to look
    centered when there's plenty of room (fullscreen)


* Javascript
** js2 refactor
  set js refactors prefix
  #+begin_src emacs-lisp
    (js2r-add-keybindings-with-prefix (kbd "C-c C-r"))
  #+end_src
** Indentation
   Two spaces is nice. Set it as default, and set evils shift width
   when in js mode as well.
  #+begin_src emacs-lisp
    (setq-default js-indent-level 2)
    (add-hook 'prelude-js-mode-hook
              (lambda() (setq evil-shift-width 2)))

    (setq-default js2-basic-offset 2)
  #+end_src

** js2 settings
  Highlighting/style settings. Don't worry about semicolons. And use harmony.
  #+begin_src emacs-lisp
    (setq-default js2-highlight-level 3)
    (setq-default js2-highlight-external-variables t)

    (setq-default js2-concat-multiline-strings t)
    (setq-default js2-strict-missing-semi-warning nil)
    (setq-default js2-pretty-multiline-declarations nil)

    (setq-default js2-language-version 200)
  #+end_src

  configuration so we use jslint, and allow node externs
  #+begin_src emacs-lisp
    (setq-default js2-include-jslint-globals t)
    (setq-default js2-include-node-externs t)
  #+end_src

** Jump to test or implementation
  Little script for jumping between tests and implementations. Made
  with a [[http://emacs.stackexchange.com/questions/7308/define-key-to-toggle-between-javascript-implementation-and-test-file/7316#7316][little help]]. Expects A structure with a lib directory for
  implementations, and a test directory for specs, Like so:
  #+BEGIN_EXAMPLE
    lib/foo.js
    lib/someDir/bar.js
    test/fooSpec.js
    test/someDir/barSpec.js
  #+END_EXAMPLE

  #+begin_src emacs-lisp
    (defun js-jump-to (current from to format-name)
      (find-file
       (cl-loop with parts = (reverse current)
                with fname = (file-name-sans-extension (cl-first parts))
                for (name . rest) on (cl-rest parts)
                until (string-equal name from)
                collect name into names
                finally (cl-return
                         (mapconcat 'identity
                                    (nconc (reverse rest)
                                           (list to)
                                           (reverse names)
                                           (list (funcall format-name fname) )) "/" )))))

    (defun js-format-impl-name (fname)
      (format "%s.js" (replace-regexp-in-string "Spec" "" fname)))

    (defun js-format-test-name (fname)
      (format "%sSpec.js" fname))

    (defun js-jump-to-implementation-or-test ()
      (interactive)
      (let ((current (split-string (buffer-file-name) "/")))
        (cond
         ((member "test" current) (js-jump-to current "test" "lib" 'js-format-impl-name))
         ((member "lib" current)  (js-jump-to current "lib" "test" 'js-format-test-name))
         (t (error "not within a test or lib directory"))
      )))
  #+end_src



* Jade
  jade-mode didn't install, so I've added it into vendor as a submodule
  and am initializing it manually
  #+begin_src emacs-lisp
    (use-package jade-mode
      :load-path "~/.emacs.d/vendor/jade-mode"
      :mode "\\.jade$")
  #+end_src


* elisp
  Emacs has warnings about documenting elisp code.
  I don't follow these rules, so disable them
  #+begin_src emacs-lisp
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  #+end_src



* Snippets And Autocompletion
** Yasnippet

   Load YASnippet configuration
   #+begin_src emacs-lisp
     (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
     (yas-reload-all)
     (add-hook 'prog-mode-hook 'yas-minor-mode)
     (add-hook 'text-mode-hook 'yas-minor-mode)
     (add-hook 'org-mode-hook  'yas-minor-mode)
   #+end_src
** Company

   Using mainly companys default prelude settings. Except I
   don't want any delay in suggestions.
   #+begin_src emacs-lisp
     (setq company-idle-delay 0)
   #+end_src

** Tab
   So, Company mode and YASnippet step on each other toes. So These
   functions are to help TAB have the behaviour I expect. Attempt
   these actions, and do the first one that works.
   1. expand yas snippet
   2. auto complete with company
   3. indent
   #+begin_src emacs-lisp
     (defun check-expansion ()
       (save-excursion
         (if (looking-at "\\_>") t
           (backward-char 1)
           (if (looking-at "\\.") t
             (backward-char 1)
             (if (looking-at "->") t nil)))))

     (defun do-yas-expand ()
       (let ((yas/fallback-behavior 'return-nil))
         (yas/expand)))

     (defun tab-indent-or-complete ()
       (interactive)
       (if (minibufferp)
           (minibuffer-complete)
         (if (or (not yas/minor-mode)
                 (null (do-yas-expand)))
             (if (check-expansion)
                 (company-complete-common)
               (indent-for-tab-command)))))
   #+end_src

   I became fairly frustrated trying to bind tab, so this is a fairly
   dirty way of altering the keymaps of company and yas-minor
   modes.

   #+begin_src emacs-lisp
     (defun bind-tab-properly ()
       "Binds tab to tab-indent-or-complete, overwritting yas and company bindings"
       (interactive)
       ;;overwrite yas and company tab mappings
       (define-key yas-minor-mode-map (kbd "<tab>") 'tab-indent-or-complete)
       (define-key yas-minor-mode-map (kbd "TAB") 'tab-indent-or-complete)
       (define-key company-active-map [tab] 'tab-indent-or-complete)
       (define-key company-active-map (kbd "TAB") 'tab-indent-or-complete))

     (add-hook 'company-mode-hook 'bind-tab-properly)

   #+end_src

*** TODO make tab binding / completion a minor mode

* Custom Commands
** create-new-empty-buffer
#+begin_src emacs-lisp
  (defun create-new-empty-buffer ()
    "Open a new empty buffer."
    (interactive)
    (let ((buf (generate-new-buffer "untitled")))
      (switch-to-buffer buf)
      (funcall (and initial-major-mode))
      (setq buffer-offer-save t)))
#+end_src

** just-my-main-window
    This is something I created with some [[http://emacs.stackexchange.com/questions/7418/define-a-main-window-and-then-close-all-others/7424#7424][help]]. The main window is
    defined per frame, and at any point I may wish to close all
    windows besides the main (to get back to work).

    #+begin_src emacs-lisp
      (defun mark-this-window-as-main ()
        "Mark the current window as the main window."
        (interactive)
        (mapc (lambda (win) (set-window-parameter win 'main nil))
          (window-list))
        (set-window-parameter nil 'main t))

      (defun get-main-window()
        "Find and return the main window or nil if non exists."
        (cl-find-if (lambda (win) (window-parameter win 'main)) (window-list)))

      (defun just-my-main-window ()
        "Show only the main window"
        (interactive)
        (delete-other-windows (get-main-window)))
    #+end_src

    Add some hooks to make sure the appropriate window is marked as
    main. That'll be code and document windows.

    #+begin_src emacs-lisp
      (add-hook 'prog-mode-hook 'mark-this-window-as-main)
      (add-hook 'text-mode-hook 'mark-this-window-as-main)
      (add-hook 'org-mode-hook 'mark-this-window-as-main)
    #+end_src



* Org-mode
** org-babel
   language definitions for org babel
   #+begin_src emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((js . t)
        (emacs-lisp . t)
        (scala . t)
        (sh . t)))
   #+end_src

   open source code blocks in new frames.
   #+begin_src emacs-lisp
     (set 'org-src-window-setup 'other-frame)
   #+end_src

   org mode maps the language mode by name, remap to proper modes
   when the language name doesn't match exactly
   #+begin_src emacs-lisp
     (add-to-list 'org-src-lang-modes '("js" . js2))
   #+end_src


* Key Bindings

  #+begin_src emacs-lisp
    ;;Unmap prelude evils ace jump
    (define-key evil-normal-state-map (kbd "SPC") nil)
    ;;remove forward motion from evil motion ma
    (define-key evil-motion-state-map " " nil)
    (defun map-all-evil-states (keys action)
      "maps key combination to action for all evil modes"
      (define-key evil-normal-state-map keys action)
      (define-key evil-insert-state-map keys action)
      (define-key evil-visual-state-map keys action))
    (defun map-n-v-evil-states (keys action)
      (define-key evil-normal-state-map keys action)
      (define-key evil-visual-state-map keys action))

    (defun map-n-i-evil-states (keys action)
      (define-key evil-normal-state-map keys action)
      (define-key evil-insert-state-map keys action))

    (define-key evil-normal-state-map (kbd "g t") 'js-jump-to-implementation-or-test)

    ;;map control s p to finding a file with projectile
    (global-set-key (kbd "C-S-p") 'projectile-find-file)

    ;;have j and k go down to next visual line
    (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)

    (global-set-key (kbd "C-c C-n") 'create-new-empty-buffer)
    (global-set-key (kbd "C-c C-o") 'just-my-main-window)
    (define-key org-mode-map (kbd "C-c C-o") 'just-my-main-window)

    (global-set-key (kbd "RET") 'newline-and-indent)

    ;;Remap alt p to switching a project with projectile
    (global-set-key (kbd "M-p") 'projectile-switch-project)

    (global-set-key (kbd "C-h") 'previous-buffer)
    (global-set-key (kbd "C-l") 'next-buffer)
    (global-set-key (kbd "C-S-h") 'winner-undo)
    (global-set-key (kbd "C-S-l") 'winner-redo)
    (global-set-key (kbd "C-c C-q") 'kill-this-buffer)

    (global-set-key (kbd "C-S-m") 'mc/mark-all-like-this-dwim)
    (map-n-v-evil-states (kbd "SPC m") 'mc/mark-next-like-this)
    (define-key mc/keymap (kbd "C-n") 'mc/mark-next-like-this)
    (define-key mc/keymap (kbd "C-S-n") 'mc/skip-to-next-like-this)
    (define-key mc/keymap (kbd "C-p") 'mc/unmark-next-like-this)
    (define-key mc/keymap (kbd "C-S-p") 'mc/unmark-previous-like-this)

    (global-set-key (kbd "C-S-SPC") 'er/contract-region)
    (global-set-key (kbd "C-SPC") 'er/expand-region)


    (map-n-v-evil-states (kbd "SPC j") 'evil-ace-jump-two-chars-mode)
    (map-n-v-evil-states (kbd "SPC r") 'js2r-rename-var)
    (map-n-v-evil-states (kbd "SPC l") 'js2r-log-this)
    (map-n-v-evil-states (kbd "SPC c") 'evilnc-comment-or-uncomment-lines)
    (map-n-v-evil-states (kbd "SPC p") 'projectile-find-file)

    (global-set-key (kbd "C-s") 'save-buffer)
    (map-n-v-evil-states (kbd "SPC s") 'save-buffer)

    (define-key evil-normal-state-map (kbd "gp") 'evil-select-last-yanked-text)

    (evil-define-key `normal org-src-mode-map (kbd "SPC '") 'org-edit-src-save-and-exit)
    (evil-define-key `normal org-mode-map (kbd "SPC '") 'org-edit-special)

    (defun org-edit-src-save-and-exit()
      (interactive)
      (org-edit-src-save)
      (org-edit-src-exit 'exit))


    ;; (map-n-v-evil-states  (kbd "SPC i") 'helm-swoop)
    (global-set-key (kbd "C-S-i") 'helm-projectile-ack)

    ;; (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    ;; (require 'helm-swoop)
    ;; (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

    (map-n-v-evil-states (kbd "go") 'view-file-other-frame)
    (define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
    (define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)

    (define-key js2-mode-map (kbd "C-c C-o") nil)
    ;; (map-n-i-evil-states (kbd "C-S-k") 'move-text-up)
    ;; (map-n-i-evil-states (kbd "C-S-j") 'move-text-down)
    ;; (evil-define-key `normal js2-mode-map (kbd "C-S-k") 'js2r-move-line-up)
    ;; (evil-define-key `insert js2-mode-map (kbd "C-S-k") 'js2r-move-line-up)
    ;; (evil-define-key `normal js2-mode-map (kbd "C-S-j") 'js2r-move-line-down)
    ;; (evil-define-key `insert js2-mode-map (kbd "C-S-j") 'js2r-line-move-down)

    ;; (define-key evil-normal-state-local-map (kbd "<right>") 'hannesr/evil-normal-move-character-forward)
    ;; (define-key evil-normal-state-local-map (kbd "<left>") 'hannesr/evil-normal-move-character-backward)
    ;; (define-key evil-visual-state-local-map (kbd "<right>") 'hannesr/evil-visual-move-selection-forward)
    ;; (define-key evil-visual-state-local-map (kbd "<left>") 'hannesr/evil-visual-move-selection-backward)

  #+end_src

** TODO Clean up keyboard shortcuts
- More consistency is needed, think about appropriate prefixes.
- Ctrl p is a poor project launching shortcut (too many
  applications use it for 'previous'


* Key chords
kj is a convenient exit compared to escape
#+begin_src emacs-lisp
  (setq key-chord-two-keys-delay 0.5)
  (key-chord-define evil-insert-state-map "kj" 'evil-normal-state)
  (key-chord-mode +1)
#+end_src

* Evil
  Evil is an emulation layer for Vim ontop of emacs. It's a very faithful emulation.

** Select last yanked text
   This function will select whatever texted you pasted last (in the buffer).
   #+begin_src emacs-lisp

     (defun evil-select-last-yanked-text ()
       "uses evils markers to select the last yanked text"
       (interactive)
       (evil-goto-mark ?\[)
       (evil-visual-char)
       (evil-goto-mark ?\]))

     ;; (defun evil-yank-and-indent-text ()
     ;;   (interactive)
     ;;   (evil-paste-after)
     ;;   (evil-indent)
     ;;   (evil-goto-mark ?\[))

   #+end_src
** Escape should exit things
  Stole this from somewhere, attempts to map escape to various
  exits. It isn't perfect however, and I still need ctrl g from time
  to time.
#+begin_src emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (define-key mc/keymap [escape] 'mc/keyboard-quit)
  (global-set-key [escape] 'evil-exit-emacs-state)
#+end_src

** Miscellaneous
#+begin_src emacs-lisp
  (require 'evil-visualstar)
  (global-evil-visualstar-mode t)
#+end_src


*** DONE Make escape work consitently
CLOSED: [2015-02-07 Sat 20:50]
    Escape fails in Helm, Js2 refactor, and I'm sure other various places

** Evil vs mutliple-cursors
  Multiple cursors and evil [[https://github.com/magnars/multiple-cursors.el/issues/17][don't play well together]]. I ripped this
  solution from [[https://github.com/jcpetkovich/.emacs.d][these configs]]. It disables evil while multiple-cursors
  is running. I don't really use multiple cursors, since not being
  able to use evil creates dissonance; But js2-refactor does. This
  allows js2-refactor to still work nicely for me.

  #+begin_src emacs-lisp
    (defun user-utils/evil-visual-or-normal-p ()
      "True if evil mode is enabled, and we are in normal or visual mode."
      (and (bound-and-true-p evil-mode)
           (not (memq evil-state '(insert emacs)))))

    (defun mc-evil-compat/switch-to-emacs-state ()
      (when (user-utils/evil-visual-or-normal-p)

        (setq mc-evil-compat/evil-prev-state evil-state)

        (when (region-active-p)
          (setq mc-evil-compat/mark-was-active t))

        (let ((mark-before (mark))
              (point-before (point)))

          (evil-emacs-state 1)

          (when (or mc-evil-compat/mark-was-active (region-active-p))
            (goto-char point-before)
            (set-mark mark-before)))))

    (defun mc-evil-compat/back-to-previous-state ()
      (when mc-evil-compat/evil-prev-state
        (unwind-protect
            (case mc-evil-compat/evil-prev-state
              ((normal visual) (evil-force-normal-state))
              (t (message "Don't know how to handle previous state: %S"
                          mc-evil-compat/evil-prev-state)))
          (setq mc-evil-compat/evil-prev-state nil)
          (setq mc-evil-compat/mark-was-active nil))))

    (add-hook 'multiple-cursors-mode-enabled-hook
              'mc-evil-compat/switch-to-emacs-state)
    (add-hook 'multiple-cursors-mode-disabled-hook
              'mc-evil-compat/back-to-previous-state)

    (defun mc-evil-compat/rectangular-switch-state ()
      (if rectangular-region-mode
          (mc-evil-compat/switch-to-emacs-state)
        (setq mc-evil-compat/evil-prev-state nil)))

    ;; When running edit-lines, point will return (position + 1) as a
    ;; result of how evil deals with regions
    (defadvice mc/edit-lines (before change-point-by-1 activate)
      (when (user-utils/evil-visual-or-normal-p)
        (if (> (point) (mark))
            (goto-char (1- (point)))
          (push-mark (1- (mark))))))

    (add-hook 'rectangular-region-mode-hook 'mc-evil-compat/rectangular-switch-state)

    (defvar mc--default-cmds-to-run-once nil)
  #+end_src

* Mutliple Cursors
#+begin_src emacs-lisp
  (require 'multiple-cursors)
  ;; Don't use expand-region fast keys
  (setq expand-region-fast-keys-enabled nil)
#+end_src

* Ace Jump
#+begin_src emacs-lisp
  (setq ace-jump-mode-scope 'frame)
  (setq ace-jump-mode-move-keys
        (loop for i from ?a to ?z collect i))

  (require 'ace-jump-mode)
  (defun evil-ace-jump-two-chars-mode (query-char query-char-2)
    "evil AceJump two chars mode"
    (interactive (list (read-char "First Char:")
                       (read-char "Second:")))

    (if (eq (ace-jump-char-category query-char) 'other)
      (error "[AceJump] Non-printable character"))

    ;; others : digit , alpha, punc
    (setq ace-jump-query-char query-char)
    (setq ace-jump-current-mode 'evil-ace-jump-char-mode)
    (ace-jump-do (regexp-quote (concat (char-to-string query-char)
                                       (char-to-string query-char-2)))))
#+end_src

* DONE helm swoop
CLOSED: [2015-02-11 Wed 14:05]
#+begin_src emacs-lisp
  (use-package helm-swoop
    :load-path "~/.emacs.d/vendor/helm-swoop"
    :config
    (setq
     helm-swoop-pre-input-function (lambda () "empty unless in visual mode"
                                     (if (evil-visual-state-p)
                                         (thing-at-point 'symbol)
                                       ""))
     helm-swoop-speed-or-color t)
    (map-n-v-evil-states  (kbd "SPC i") 'helm-swoop)
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
#+end_src

* wgrep-ag
#+begin_src emacs-lisp
  (use-package wgrep
    :load-path "~/.emacs.d/vendor/Emacs-wgrep"
    :config
    (progn
      (use-package wgrep-helm)
      (use-package wgrep-ack)
      ;; (use-package wgrep-ag)

      ;; (use-package helm-ag
      ;;   :ensure t
      ;;   :load-path "~/.emacs.d/vendor/emacs-helm-ag"
      ;;   :config
      ;;   (define-key helm-ag-map (kbd "C-c C-s") 'helm-grep-save-results))
      ;; )
      ))

#+end_src

* Drag Stuff
#+begin_src emacs-lisp
  (use-package drag-stuff
      :load-path "~/.emacs.d/vendor/drag-stuff.el"
      :bind
      (("C-S-j" . drag-stuff-down)
       ("C-S-k" . drag-stuff-up))
      :config
      (drag-stuff-mode t))
#+end_src
** TODO Evil compatibility improvements
- [ ] visual line mode is broken.
- [ ] being able to move rectangular regions would be nice

* TODO Refactor emacs configuration
- [ ] use, use-package, for more cohesion.
- [ ] transition away from prelude


* TODO Bring in node REPL mode from chromebook
- [ ] configure for es6 with 6to5
- [ ] Clean up implementation
- [ ] pull from chromebook into master
* TODO Find a way to highlight all occurrences of variable
- Do it with js2 AST http://mihai.bazon.net/projects/editing-javascript-with-emacs-js2-mode/js2-highlight-vars-mode

* TODO Fix copy and paste between emacs and clipboard
Probably evil related, since being in insert mode when doing the copy seems to work.
