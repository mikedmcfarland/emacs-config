#+STARTUP: showall indent
#+options: num:nil
#+BEGIN_HTML
---
title: Emacs Configuration
date: 2015-01-30
draft: false
---
#+END_HTML

#+TITLE: Emacs Configuration


* About
** This File
  This is an emacs org-mode file which generates my personal emacs
  configuration. These settings are used along side [[http://github.com/bbatsov/prelude][Emacs Prelude]]. I
  share my config across multiple machines and use git to version it.
  [[http://github.com/mikedmcfarland/emacs-config][Here is my configuration on github]].

** This  Emacs Config
  My workflow involves running mainly one window in a frame. And
  running many frames at once (all in daemon mode). Many settings are
  a consequence of this.

  *Why?*

  I run emacs in a [[http://i3wm.org][tiling window manager]], it takes care of tabing and
  window management needs. Its nicer when all my programs operate
  tabs/windowing consistently.

* Emacs initialization

** Personal Information
  Set my name and email
  #+begin_src emacs-lisp
    (setq user-full-name "Mike McFarland"
          user-mail-address "mikedmcfarland@gmail.com")
  #+end_src

** Prelude Modules
   Prelude includes many packages you can toggle. Here's [[https://github.com/mikedmcfarland/emacs-config/blob/master/prelude-modules.el][the list]] I enabled.


** Packages
   My required packages, prelude will make sure these are downloaded
   and required at startup.
   #+begin_src emacs-lisp
     (prelude-require-packages
      '(s
        monokai-theme
        restclient
        powerline-evil
        yasnippet
        multiple-cursors
        expand-region
        evil-nerd-commenter
        js2-refactor
        ))
   #+end_src

** Backups
    store backups in one folder instead next to the file
    #+begin_src emacs-lisp
      (setq backup-directory-alist `(("." . "~/.emacs.d/.backups")))
    #+end_src

** Save Place
    Save cursor position when reopening a file
    #+begin_src emacs-lisp
      (setq save-place-file "~/.emacs.d/saveplace")
      (setq-default save-place t)
      (require 'saveplace)
    #+end_src

** Aesthetics
   Load the monokai theme (Sublime Text's default colors)
   #+begin_src emacs-lisp
     (load-theme 'monokai t)
   #+end_src

   Make sure we edit using visual lines, instead of actual line breaks.
   Helps when word wrapping is on.
   #+begin_src emacs-lisp
     (global-visual-line-mode t)
   #+end_src

   set the font, this seems to work for the emacs daemon, other methods
   were requiring me to re-run expressions after connecting another client
   #+begin_src emacs-lisp
     (add-to-list 'default-frame-alist '(font .   "Source Code Pro 12" ))
   #+end_src

   A few miscallaneious things
   #+begin_src emacs-lisp
     (display-time-mode t)

     ;;smooth scrolling
     (setq scroll-margin 5
           scroll-conservatively 9999
           scroll-step 1)

    (defun set-my-margins()
      (setq left-margin-width 1)
      (setq right-margin-width 1))

    (add-hook 'text-mode-hook 'set-my-margins)
    (add-hook 'prog-mode-hook 'set-my-margins)

    (powerline-evil-vim-color-theme)
   #+end_src

*** TODO make margins dynamic
    currently we have static margins, it'd be nice to allow things to look
    centered when there's plenty of room (fullscreen)


* Javascript
** js2 refactor
  set js refactors prefix
  #+begin_src emacs-lisp
    (js2r-add-keybindings-with-prefix (kbd "C-c C-r"))
  #+end_src
** Indentation
   Two spaces is nice. Set it as default, and set evils shift width
   when in js mode as well.
  #+begin_src emacs-lisp
    (setq-default js-indent-level 2)
    (add-hook 'prelude-js-mode-hook
              (lambda() (setq evil-shift-width 2)))

    (setq-default js2-basic-offset 2)
  #+end_src

** js2 settings
  Highlighting/style settings. Don't worry about semicolons. And use harmony.
  #+begin_src emacs-lisp
    (setq-default js2-highlight-level 3)
    (setq-default js2-highlight-external-variables t)

    (setq-default js2-concat-multiline-strings t)
    (setq-default js2-strict-missing-semi-warning nil)
    (setq-default js2-pretty-multiline-declarations nil)

    (setq-default js2-language-version 200)
  #+end_src

  configuration so we use jslint, and allow node externs
  #+begin_src emacs-lisp
    (setq-default js2-include-jslint-globals t)
    (setq-default js2-include-node-externs t)
  #+end_src

** Jump to test or implementation
  Little script for jumping between tests and implementations. Made
  with a [[http://emacs.stackexchange.com/questions/7308/define-key-to-toggle-between-javascript-implementation-and-test-file/7316#7316][little help]]. Expects A structure with a lib directory for
  implementations, and a test directory for specs, Like so:
  #+BEGIN_EXAMPLE
    lib/foo.js
    lib/someDir/bar.js
    test/fooSpec.js
    test/someDir/barSpec.js
  #+END_EXAMPLE

  #+begin_src emacs-lisp
    (defun js-jump-to (current from to format-name)
      (find-file
       (cl-loop with parts = (reverse current)
                with fname = (file-name-sans-extension (cl-first parts))
                for (name . rest) on (cl-rest parts)
                until (string-equal name from)
                collect name into names
                finally (cl-return
                         (mapconcat 'identity
                                    (nconc (reverse rest)
                                           (list to)
                                           (reverse names)
                                           (list (funcall format-name fname) )) "/" )))))

    (defun js-format-impl-name (fname)
      (format "%s.js" (replace-regexp-in-string "Spec" "" fname)))

    (defun js-format-test-name (fname)
      (format "%sSpec.js" fname))

    (defun js-jump-to-implementation-or-test ()
      (interactive)
      (let ((current (split-string (buffer-file-name) "/")))
        (cond
         ((member "test" current) (js-jump-to current "test" "lib" 'js-format-impl-name))
         ((member "lib" current)  (js-jump-to current "lib" "test" 'js-format-test-name))
         (t (error "not within a test or lib directory"))
      )))
  #+end_src



* Jade
  jade-mode didn't install, so I've added it into vendor as a submodule
  and am initializing it manually
  #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/vendor/jade-mode")
    (require 'jade-mode)
    (add-to-list 'auto-mode-alist '("\\.jade$" . jade-mode))
  #+end_src


* elisp
  Emacs has warnings about documenting elisp code.
  I don't follow these rules, so disable them
  #+begin_src emacs-lisp
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  #+end_src



* Snippets And Autocompletion
** Yasnippet

   Load YASnippet configuration
   #+begin_src emacs-lisp
     (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
     (yas-reload-all)
     (add-hook 'prog-mode-hook 'yas-minor-mode)
     (add-hook 'text-mode-hook 'yas-minor-mode)
     (add-hook 'org-mode-hook  'yas-minor-mode)
   #+end_src
** Company

   Using mainly companys default prelude settings. Except I
   don't want any delay in suggestions.
   #+begin_src emacs-lisp
     (setq company-idle-delay 0)
   #+end_src

** Tab
   So, Company mode and YASnippet step on each other toes. So These
   functions are to help TAB have the behaviour I expect. Attempt
   these actions, and do the first one that works.
   1. expand yas snippet
   2. auto complete with company
   3. indent
   #+begin_src emacs-lisp
     (defun check-expansion ()
       (save-excursion
         (if (looking-at "\\_>") t
           (backward-char 1)
           (if (looking-at "\\.") t
             (backward-char 1)
             (if (looking-at "->") t nil)))))

     (defun do-yas-expand ()
       (let ((yas/fallback-behavior 'return-nil))
         (yas/expand)))

     (defun tab-indent-or-complete ()
       (interactive)
       (if (minibufferp)
           (minibuffer-complete)
         (if (or (not yas/minor-mode)
                 (null (do-yas-expand)))
             (if (check-expansion)
                 (company-complete-common)
               (indent-for-tab-command)))))
   #+end_src

   I became fairly frustrated trying to bind tab, so this is a fairly
   dirty way of altering the keymaps of company and yas-minor
   modes.

   #+begin_src emacs-lisp
     (defun bind-tab-properly ()
       "Binds tab to tab-indent-or-complete, overwritting yas and company bindings"
       (interactive)
       ;;overwrite yas and company tab mappings
       (define-key yas-minor-mode-map (kbd "<tab>") 'tab-indent-or-complete)
       (define-key yas-minor-mode-map (kbd "TAB") 'tab-indent-or-complete)
       (define-key company-active-map [tab] 'tab-indent-or-complete)
       (define-key company-active-map (kbd "TAB") 'tab-indent-or-complete))

     (add-hook 'company-mode-hook 'bind-tab-properly)

   #+end_src

*** TODO make tab binding / completion a minor mode

* Custom Commands
** create-new-empty-buffer
#+begin_src emacs-lisp
  (defun create-new-empty-buffer ()
    "Open a new empty buffer."
    (interactive)
    (let ((buf (generate-new-buffer "untitled")))
      (switch-to-buffer buf)
      (funcall (and initial-major-mode))
      (setq buffer-offer-save t)))
#+end_src

** just-my-main-window
    This is something I created with some [[http://emacs.stackexchange.com/questions/7418/define-a-main-window-and-then-close-all-others/7424#7424][help]]. The main window is
    defined per frame, and at any point I may wish to close all
    windows besides the main (to get back to work).

    #+begin_src emacs-lisp
      (defun mark-this-window-as-main ()
        "Mark the current window as the main window."
        (interactive)
        (mapc (lambda (win) (set-window-parameter win 'main nil))
          (window-list))
        (set-window-parameter nil 'main t))

      (defun get-main-window()
        "Find and return the main window or nil if non exists."
        (cl-find-if (lambda (win) (window-parameter win 'main)) (window-list)))

      (defun just-my-main-window ()
        "Show only the main window"
        (interactive)
        (delete-other-windows (get-main-window)))
    #+end_src

    Add some hooks to make sure the appropriate window is marked as
    main. That'll be code and document windows.

    #+begin_src emacs-lisp
      (add-hook 'prog-mode-hook 'mark-this-window-as-main)
      (add-hook 'text-mode-hook 'mark-this-window-as-main)
      (add-hook 'org-mode-hook 'mark-this-window-as-main)
    #+end_src



* Org-mode
** org-babel
   language definitions for org babel
   #+begin_src emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((js . t)
        (emacs-lisp . t)
        (scala . t)
        (sh . t)))
   #+end_src

* Global Key Bindings

  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c C-m") 'just-my-main-window)

    (global-set-key (kbd "C-j") 'company-select-next-or-abort)
    (global-set-key (kbd "C-k") 'company-select-previous-or-abort)

    (global-set-key (kbd "RET") 'newline-and-indent)

    (global-set-key (kbd "C-p") 'projectile-find-file)
    ;;Remap alt p to switching a project with projectile
    (global-set-key (kbd "M-p") 'projectile-switch-project)

    ;;Have no idea why up and down are doing absurd things, but this helped
    (global-set-key (kbd "<up>") 'evil-previous-visual-line)
    (global-set-key (kbd "<down>") 'evil-next-visual-line)
    (global-set-key (kbd "C-h") 'previous-buffer)
    (global-set-key (kbd "C-l") 'next-buffer)
    (global-set-key (kbd "C-q") 'kill-this-buffer)

    (global-set-key (kbd "C-S-SPC") 'er/contract-region)
    (global-set-key (kbd "C-SPC") 'er/expand-region)
  #+end_src

** TODO Clean up keyboard shortcuts
- More consistency is needed, think about appropriate prefixes.
- Ctrl p is a poor project launching shortcut (too many
  applications use it for 'previous'




* Evil Key Bindings

  #+begin_src emacs-lisp
    (defun map-all-evil-states (keys action)
      "maps key combination to action for all evil modes"
      (define-key evil-normal-state-map keys action)
      (define-key evil-insert-state-map keys action)
      (define-key evil-visual-state-map keys action))

    (define-key evil-insert-state-map (kbd "C-j") 'company-select-next-or-abort)
    (define-key evil-insert-state-map (kbd "C-k") 'company-select-previous-or-abort)

    (map-all-evil-states (kbd "C-S-r") 'js2r-rename-var)
    (map-all-evil-states (kbd "C-S-l") 'js2r-log-this)
    (map-all-evil-states (kbd "C-t")   'js-jump-to-implementation-or-test)

    ;;map control p to finding a file with projectile
    (map-all-evil-states (kbd "C-p") 'projectile-find-file)

    ;;have j and k go down to next visual line
    (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)

    (map-all-evil-states (kbd "C-s") 'save-buffer)
    (map-all-evil-states (kbd "C-n") 'create-new-empty-buffer)
    (map-all-evil-states (kbd "C-/") 'evilnc-comment-or-uncomment-lines)
    (define-key evil-normal-state-map (kbd "gp") 'evil-select-last-yanked-text)
  #+end_src


* Evil
  Evil is an emulation layer for Vim ontop of emacs. It's a very faithful emulation.

** Select last yanked text
   This function will select whatever texted you pasted last (in the buffer).
   #+begin_src emacs-lisp
     (defun evil-select-last-yanked-text ()
       "uses evils markers to select the last yanked text"
       (interactive)
       (evil-goto-mark ?\[)
       (evil-visual-char)
       (evil-goto-mark ?\]))
   #+end_src
** kj to exit insert mode
  kj is more convenient then escape for exiting insert mode
  #+begin_src emacs-lisp
    ;;Define KJ as espace while in insert
    (define-key evil-insert-state-map "k" #'cofi/maybe-exit)

    (evil-define-command cofi/maybe-exit ()
      :repeat change
      (interactive)
      (let ((modified (buffer-modified-p)))
        (insert "k")
        (let ((evt (read-event (format "Insert %c to exit insert state" ?j)
                               nil 0.5)))
          (cond
           ((null evt) (message ""))
           ((and (integerp evt) (char-equal evt ?j))
            (delete-char -1)
            (set-buffer-modified-p modified)
            (push 'escape unread-command-events))
           (t (setq unread-command-events (append unread-command-events
                                                  (list evt))))))))
  #+end_src

** Escape should exit things
  Stole this from somewhere, attempts to map escape to various
  exits. It isn't perfect however, and I still need ctrl g from time
  to time.
#+begin_src emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (global-set-key [escape] 'evil-exit-emacs-state)
#+end_src

*** TODO Make escape work consitently
    Escape fails in Helm, Js2 refactor, and I'm sure other various places


** Evil vs mutliple-cursors
  Multiple cursors and evil [[https://github.com/magnars/multiple-cursors.el/issues/17][don't play well together]]. I ripped this
  solution from [[https://github.com/jcpetkovich/.emacs.d][these configs]]. It disables evil while multiple-cursors
  is running. I don't really use multiple cursors, since not being
  able to use evil creates dissonance; But js2-refactor does. This
  allows js2-refactor to still work nicely for me.

  #+begin_src emacs-lisp
    (defun user-utils/evil-visual-or-normal-p ()
      "True if evil mode is enabled, and we are in normal or visual mode."
      (and (bound-and-true-p evil-mode)
           (not (memq evil-state '(insert emacs)))))

    (defun mc-evil-compat/switch-to-emacs-state ()
      (when (user-utils/evil-visual-or-normal-p)

        (setq mc-evil-compat/evil-prev-state evil-state)

        (when (region-active-p)
          (setq mc-evil-compat/mark-was-active t))

        (let ((mark-before (mark))
              (point-before (point)))

          (evil-emacs-state 1)

          (when (or mc-evil-compat/mark-was-active (region-active-p))
            (goto-char point-before)
            (set-mark mark-before)))))

    (defun mc-evil-compat/back-to-previous-state ()
      (when mc-evil-compat/evil-prev-state
        (unwind-protect
            (case mc-evil-compat/evil-prev-state
              ((normal visual) (evil-force-normal-state))
              (t (message "Don't know how to handle previous state: %S"
                          mc-evil-compat/evil-prev-state)))
          (setq mc-evil-compat/evil-prev-state nil)
          (setq mc-evil-compat/mark-was-active nil))))

    (add-hook 'multiple-cursors-mode-enabled-hook
              'mc-evil-compat/switch-to-emacs-state)
    (add-hook 'multiple-cursors-mode-disabled-hook
              'mc-evil-compat/back-to-previous-state)

    (defun mc-evil-compat/rectangular-switch-state ()
      (if rectangular-region-mode
          (mc-evil-compat/switch-to-emacs-state)
        (setq mc-evil-compat/evil-prev-state nil)))

    ;; When running edit-lines, point will return (position + 1) as a
    ;; result of how evil deals with regions
    (defadvice mc/edit-lines (before change-point-by-1 activate)
      (when (user-utils/evil-visual-or-normal-p)
        (if (> (point) (mark))
            (goto-char (1- (point)))
          (push-mark (1- (mark))))))

    (add-hook 'rectangular-region-mode-hook 'mc-evil-compat/rectangular-switch-state)

    (defvar mc--default-cmds-to-run-once nil)
  #+end_src

* TODO Investigate helm swoop
This looks pretty powerful, and may replace any need for multiple
cursors (for my editing needs). Confirm it plays nice with evil.


* TODO Bring in node REPL mode from chromebook
- [ ] configure for es6 with 6to5
- [ ] Clean up implementation
- [ ] pull from chromebook into master
