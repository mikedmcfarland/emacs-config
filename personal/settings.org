#+BEGIN_HTML
---
title: Emacs Configuration
date: 2015-01-29
draft: false
tags : [linux]
---
#+END_HTML
#+FILETAGS: :computer:
#+TITLE: Emacs Configuration

* About
** This File
  This is an emacs org-mode file which generates my personal emacs
  configuration. These settings are used along side [[http://github.com/bbatsov/prelude][Emacs Prelude]]. I
  share my config across multiple machines and use git to version it.
  [[http://github.com/mikedmcfarland/emacs-config][Here is my configuration on github]].

** This  Emacs Config
  My workflow involves running mainly one window in a frame. And
  running many frames at once (all in daemon mode). Many settings are
  a consequence of this.

  *Why?*

  I run emacs in a [[http://i3wm.org][tiling window manager]], it takes care of tabing and
  window management needs. Its nicer when all my programs operate
  tabs/windowing consistently.

* Emacs initialization

** Personal Information
Set my name and email
  #+begin_src emacs-lisp
    (setq user-full-name "Mike McFarland"
          user-mail-address "mikedmcfarland@gmail.com")
  #+end_src

** Prelude Modules
   Prelude includes many packages you can toggle. Here's [[https://github.com/mikedmcfarland/emacs-config/blob/master/prelude-modules.el][the list]] I enabled.


** Packages
   My required packages, prelude will make sure these are downloaded
   and required at startup.
   #+begin_src emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/vendor/use-package")
     (require 'use-package)

     (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))

     (prelude-require-packages
      '(s
        monokai-theme
        restclient
        powerline-evil
        yasnippet
        multiple-cursors
        expand-region
        evil-nerd-commenter
        js2-refactor
        key-chord))
   #+end_src

** Backups
    store backups in one folder instead next to the file
    #+begin_src emacs-lisp
      (setq backup-directory-alist `(("." . "~/.emacs.d/.backups")))

      (setq make-backup-files t               ; backup of a file the first time it is saved.
            backup-by-copying t               ; don't clobber symlinks
            version-control t                 ; version numbers for backup files
            delete-old-versions t             ; delete excess backup files silently
            delete-by-moving-to-trash t
            kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
            kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
            auto-save-default t               ; auto-save every buffer that visits a file
            auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
            auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
            )

    #+end_src

** Save Place
    Save cursor position when reopening a file
    #+begin_src emacs-lisp
      (setq save-place-file "~/.emacs.d/saveplace")
      (setq-default save-place t)
      (require 'saveplace)
    #+end_src

** Aesthetics
   Load the monokai theme (Sublime Text's default colors)
   #+begin_src emacs-lisp
     (load-theme 'monokai t)
   #+end_src

   Make sure we edit using visual lines, instead of actual line breaks.
   Helps when word wrapping is on.
   #+begin_src emacs-lisp
     (global-visual-line-mode t)
   #+end_src

   set the font, this seems to work for the emacs daemon, other methods
   were requiring me to re-run expressions after connecting another client
   #+begin_src emacs-lisp
     (add-to-list 'default-frame-alist '(font .   "Source Code Pro 12" ))
   #+end_src


   A few miscallaneious things
   #+begin_src emacs-lisp
     (display-time-mode t)

     ;;smooth scrolling
     (setq scroll-margin 5
           scroll-conservatively 9999
           scroll-step 1)

    (defun set-my-margins()
      (setq left-margin-width 1)
      (setq right-margin-width 1))

    (add-hook 'text-mode-hook 'set-my-margins)
    (add-hook 'prog-mode-hook 'set-my-margins)

    (powerline-evil-vim-color-theme)
   #+end_src

*** TODO [#C] make margins dynamic
    currently we have static margins, it'd be nice to allow things to look
    centered when there's plenty of room (fullscreen)

** Configuration helpers
I map evil shortcuts allot, these are those mappings shorter.
   #+begin_src emacs-lisp
     ;;Unmap prelude evils ace jump
     (define-key evil-normal-state-map (kbd "SPC") nil)

     (defun map-all-evil-states (keys action)
       "maps key combination to action for all evil modes"
       (define-key evil-normal-state-map keys action)
       (define-key evil-insert-state-map keys action)
       (define-key evil-visual-state-map keys action))
     (defun map-n-v-evil-states (keys action)
       (define-key evil-normal-state-map keys action)
       (define-key evil-visual-state-map keys action))

     (defun map-n-i-evil-states (keys action)
       (define-key evil-normal-state-map keys action)
       (define-key evil-insert-state-map keys action))
   #+end_src
* Javascript
** js2 refactor
  set js refactors prefix
  #+begin_src emacs-lisp
    (js2r-add-keybindings-with-prefix (kbd "C-c C-r"))
  #+end_src
** Indentation
   Two spaces is nice. Set it as default, and set evils shift width
   when in js mode as well.
  #+begin_src emacs-lisp
    (setq-default js-indent-level 2)
    (add-hook 'prelude-js-mode-hook
              (lambda() (setq evil-shift-width 2)))

    (setq-default js2-basic-offset 2)
  #+end_src

** js2 settings
  Highlighting/style settings. Don't worry about semicolons. And use harmony.
  #+begin_src emacs-lisp
    (setq-default js2-highlight-level 3)
    (setq-default js2-highlight-external-variables t)

    (setq-default js2-concat-multiline-strings t)
    (setq-default js2-strict-missing-semi-warning nil)
    (setq-default js2-pretty-multiline-declarations nil)

    (setq-default js2-language-version 200)
  #+end_src

  configuration so we use jslint, and allow node externs
  #+begin_src emacs-lisp
    (setq-default js2-include-jslint-globals t)
    (setq-default js2-include-node-externs t)
  #+end_src

** Jump to test or implementation
  Little script for jumping between tests and implementations. Made
  with a [[http://emacs.stackexchange.com/questions/7308/define-key-to-toggle-between-javascript-implementation-and-test-file/7316#7316][little help]]. Expects A structure with a lib directory for
  implementations, and a test directory for specs, Like so:
  #+BEGIN_EXAMPLE
    lib/foo.js
    lib/someDir/bar.js
    test/fooSpec.js
    test/someDir/barSpec.js
  #+END_EXAMPLE

  #+begin_src emacs-lisp
    (defun js-jump-to (current from to format-name)
      (find-file
       (cl-loop with parts = (reverse current)
                with fname = (file-name-sans-extension (cl-first parts))
                for (name . rest) on (cl-rest parts)
                until (string-equal name from)
                collect name into names
                finally (cl-return
                         (mapconcat 'identity
                                    (nconc (reverse rest)
                                           (list to)
                                           (reverse names)
                                           (list (funcall format-name fname) )) "/" )))))

    (defun js-format-impl-name (fname)
      (format "%s.js" (replace-regexp-in-string "Spec" "" fname)))

    (defun js-format-test-name (fname)
      (format "%sSpec.js" fname))

    (defun js-jump-to-implementation-or-test ()
      (interactive)
      (let ((current (split-string (buffer-file-name) "/")))
        (cond
         ((member "test" current) (js-jump-to current "test" "lib" 'js-format-impl-name))
         ((member "lib" current)  (js-jump-to current "lib" "test" 'js-format-test-name))
         (t (error "not within a test or lib directory"))
      )))
  #+end_src

** align declarations
Aligning require statements at the top, or variable literal assignments
is something that can make code more readable, but its too painful to do
manually all the time. This seeks out '=' or ':' in lines, and aligns them.

#+begin_src emacs-lisp
  (defun js-align-assignments (&optional NUM)
    (interactive "p")
    ;;Keep them separate align calls, otherwise colons align with spaces
    ;;if they're in the same region
    (align-regexp (region-beginning) (region-end) "\\(\\s-*\\)=")
    (align-regexp (region-beginning) (region-end) "\\(\\s-*\\):"))

  (evil-define-key `normal js2-mode-map (kbd "SPC \\") 'js-align-assignments)
  (evil-define-key `visual js2-mode-map (kbd "SPC \\") 'js-align-assignments)

#+end_src




* Jade
  #+begin_src emacs-lisp
    (use-package jade-mode
      :load-path "~/.emacs.d/vendor/jade-mode"
      :mode "\\.jade$")
  #+end_src


* elisp
  Emacs has warnings about documenting elisp code.
  I don't follow these rules, so disable them
  #+begin_src emacs-lisp
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  #+end_src


* dot diagrams
#+begin_src emacs-lisp
  (use-package graphviz-dot-mode
    :load-path "~/.emacs.d/vendor/graphviz-dot-mode"
    :mode "\\.dot$")
#+end_src

* Snippets And Autocompletion
** Yasnippet

   Load YASnippet configuration
   #+begin_src emacs-lisp
     (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
     (yas-reload-all)
     (add-hook 'prog-mode-hook 'yas-minor-mode)
     (add-hook 'text-mode-hook 'yas-minor-mode)
     (add-hook 'org-mode-hook  'yas-minor-mode)
   #+end_src
** Company

   Using mainly companys default prelude settings. Except I
   don't want any delay in suggestions.
   #+begin_src emacs-lisp
     (setq company-idle-delay 0)
   #+end_src

** Tab
   So, Company mode and YASnippet step on each other toes. So These
   functions are to help TAB have the behaviour I expect. Attempt
   these actions, and do the first one that works.
   1. expand yas snippet
   2. auto complete with company
   3. indent
   #+begin_src emacs-lisp
     (defun check-expansion ()
       (save-excursion
         (if (looking-at "\\_>") t
           (backward-char 1)
           (if (looking-at "\\.") t
             (backward-char 1)
             (if (looking-at "->") t nil)))))

     (defun do-yas-expand ()
       (let ((yas/fallback-behavior 'return-nil))
         (yas/expand)))

     (defun tab-indent-or-complete ()
       (interactive)
       (if (minibufferp)
           (minibuffer-complete)
         (if (or (not yas/minor-mode)
                 (null (do-yas-expand)))
             (if (check-expansion)
                 (company-complete-common)
               (indent-for-tab-command)))))
   #+end_src

   I became fairly frustrated trying to bind tab, so this is a fairly
   dirty way of altering the keymaps of company and yas-minor
   modes.

   #+begin_src emacs-lisp
     (defun bind-tab-properly ()
       "Binds tab to tab-indent-or-complete, overwritting yas and company bindings"
       (interactive)
       ;;overwrite yas and company tab mappings
       (define-key yas-minor-mode-map (kbd "<tab>") 'tab-indent-or-complete)
       (define-key yas-minor-mode-map (kbd "TAB") 'tab-indent-or-complete)
       (define-key company-active-map [tab] 'tab-indent-or-complete)
       (define-key company-active-map (kbd "TAB") 'tab-indent-or-complete))

     (add-hook 'company-mode-hook 'bind-tab-properly)

   #+end_src

*** TODO [#C] make tab binding / completion a minor mode

* Custom Commands
** create-new-empty-buffer
#+begin_src emacs-lisp
  (defun create-new-empty-buffer ()
    "Open a new empty buffer."
    (interactive)
    (let ((buf (generate-new-buffer "untitled")))
      (switch-to-buffer buf)
      (funcall (and initial-major-mode))
      (setq buffer-offer-save t)))
#+end_src

** just-my-main-window
    This is something I created with some [[http://emacs.stackexchange.com/questions/7418/define-a-main-window-and-then-close-all-others/7424#7424][help]]. The main window is
    defined per frame, and at any point I may wish to close all
    windows besides the main (to get back to work).

    #+begin_src emacs-lisp
      (defun mark-this-window-as-main ()
        "Mark the current window as the main window."
        (interactive)
        (mapc (lambda (win) (set-window-parameter win 'main nil))
          (window-list))
        (set-window-parameter nil 'main t))

      (defun get-main-window()
        "Find and return the main window or nil if non exists."
        (cl-find-if (lambda (win) (window-parameter win 'main)) (window-list)))

      (defun just-my-main-window ()
        "Show only the main window"
        (interactive)
        (delete-other-windows (get-main-window)))
    #+end_src

    Add some hooks to make sure the appropriate window is marked as
    main. That'll be code and document windows.

    #+begin_src emacs-lisp
      (add-hook 'prog-mode-hook 'mark-this-window-as-main)
      (add-hook 'text-mode-hook 'mark-this-window-as-main)
      (add-hook 'org-mode-hook 'mark-this-window-as-main)
    #+end_src


* Org-mode
** Misc
Automatically put us into org-indent-mode when editing org files
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

** org-babel
language definitions for org babel
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((js . t)
     (emacs-lisp . t)
     (scala . t)
     (sh . t)
     (dot . t)
     ))
#+end_src

open source code blocks in new frames.
#+begin_src emacs-lisp
  (set 'org-src-window-setup 'current-window)
#+end_src

org mode maps the language mode by name, remap to proper modes
when the language name doesn't match exactly
#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("js" . js2))
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+end_src

lets use babel-node instead of node (for es6 features).
This needs babel installed globally to work.
#+begin_src emacs-lisp
  (setq org-babel-js-cmd "babel-node")
#+end_src

use relative file links when tangling/detangling
#+begin_src emacs-lisp
  (setq org-babel-tangle-use-relative-file-links t)
#+end_src


** org-agenda

Pull in all org files for my agenda from:
- my ~/notes directory
- recursively through my ~/projects

   #+begin_src emacs-lisp
  (defun update-org-agenda-files ()
    (interactive)
    (let*
        ((entries
          '("~/notes"))
         (rec-entries
          '("~/projects"))
         (rec-files
          (mapcan
           'find-org-file-recursively
           rec-entries))

         (all-org-files (append entries rec-files)))
      (setq org-agenda-files all-org-files)))

  (defun find-org-file-filter (name)
    (not (s-contains? "node_modules" name)))

  ;; recursively find .org files in provided directory
  ;; modified from an Emacs Lisp Intro example
  (defun find-org-file-recursively (directory &optional filext)
    "Return .org and .org_archive files recursively from DIRECTORY.
  If FILEXT is provided, return files with extension FILEXT instead."
    ;; FIXME: interactively prompting for directory and file extension
    (let* (org-file-list
           (case-fold-search t)           ; filesystems are case sensitive
           (file-name-regex "^[^.#].*")   ; exclude .*
           (filext (if filext filext "org$\\\|org_archive"))
           (fileregex (format "%s\\.\\(%s$\\)" file-name-regex filext))
           (cur-dir-list (directory-files directory t file-name-regex)))
      ;; loop over directory listing
      (dolist (file-or-dir cur-dir-list org-file-list) ; returns org-file-list
        (cond
         ((file-regular-p file-or-dir) ; regular files
          (if (string-match fileregex file-or-dir) ; org files
              (add-to-list 'org-file-list file-or-dir)))
         ((file-directory-p file-or-dir)
          (if (find-org-file-filter file-or-dir)
              (dolist (org-file (find-org-file-recursively file-or-dir filext)
                                org-file-list) ; add files found to result
                (add-to-list 'org-file-list org-file))))))))

  (update-org-agenda-files)

   #+end_src



Configure shortcuts and settings for org agenda
   #+begin_src emacs-lisp
  (use-package org-agenda
    :bind ("C-c a" . org-agenda)
    :config
    (progn
      ;;we dont use evil in agenda, but j/k should be vim style
      (define-key org-agenda-mode-map "j" 'org-agenda-next-line)
      (define-key org-agenda-mode-map "k" 'org-agenda-previous-line)
      ;; (setq org-agenda-start-with-follow-mode t)
      ))
   #+end_src

** Org capture
Set up capture templates and shortcuts.
   #+begin_src emacs-lisp
     (use-package org-capture
       :config
       (progn
         (setq org-capture-templates
               '(
                 ("t" "Todo" entry (file+headline "~/notes/tasks.org" "Tasks")
                  "* TODO %?\n  %i\n  %a")
                 ("e" "Emacs Todo" entry (file+headline "~/.emacs.d/personal/settings.org" "Tasks")
                  "* TODO %?\n  %i\n  %a")
                 ("p" "Project Todo" entry (function bear-org-project-jump-to-tasks)
                  "* TODO %?\n  %i\n  %a")
                 ("j" "Journal" entry (file+datetree "~/notes/journal.org")
                  "* %?\nEntered on %U\n  %i\n  %a")))

         (map-n-v-evil-states " oc" 'org-capture)
         ))
   #+end_src

These functions allow the project template to work.
They add tasks to the appropriate org file (and section) based on the current project.

   #+begin_src emacs-lisp
     (defun bear-org-jump-to-tasks()
       "Jumps to the tasks within the current org file. If no task section
     exists, one is created"
       (interactive)
       (goto-char (point-min))
       (unless
           (re-search-forward
            "^[[:space:]]*\\*.[[:space:]]*\\(tasks\\|planned\\|todos\\)[[:space:]]*"
            nil t)
         (progn
           (goto-char (point-max))
           (newline)
           (insert "* Tasks")
           (newline))))

     (defun bear-org-project-jump ()
       "Jumps to the projects org file (dominating file named readme.org or
     todo.org in)"
       (interactive)
       (let* ((dir (file-name-directory (buffer-file-name)))
              (match "^\\([rR][eE][aA][dD][mM][dE]\\|[tT][oO][dD][oO]\\)\\.[oO][rR][gG]$")
              (get-matched (lambda(parent) (car (directory-files parent nil match))))
              (matched-dir (locate-dominating-file dir get-matched))
              (matched-file (funcall get-matched matched-dir)))
         (find-file (concat matched-dir matched-file))))


     (defun bear-org-project-jump-to-tasks ()
       "Finds the org file and location associated with project tasks, and jumps to it"
       (interactive)
       (if (string= (file-name-extension (buffer-file-name)) "org")
           (bear-org-jump-to-tasks)
         (progn
           (bear-org-project-jump)
           (bear-org-jump-to-tasks))))
   #+end_src

** Org-clock (time-tracking)
set up org clocking shortcuts and settings
   #+begin_src emacs-lisp
     (setq org-clock-persist 'history)
     (org-clock-persistence-insinuate)

     (use-package org-clock
       :config
       (progn
         (map-n-v-evil-states " oki" 'org-clock-in)
         (map-n-v-evil-states " oko" 'org-clock-out)
         (map-n-v-evil-states " okx" 'org-clock-in-last)
         (map-n-v-evil-states " oke" 'org-clock-out)
         (add-hook 'org-clock-in-prepare-hook
                   'my-org-mode-ask-effort)

         (defun my-org-mode-ask-effort ()
           "Ask for an effort estimate when clocking in."
           (unless (org-entry-get (point) "Effort")
             (let ((effort
                    (completing-read
                     "Effort: "
                     (org-entry-get-multivalued-property (point) "Effort"))))
               (unless (equal effort "")
                 (org-set-property "Effort" effort)))))
         ))

   #+end_src


* Key Bindings
A bunch of keybindings that really should be put into appropriate sections.
  #+begin_src emacs-lisp
    ;;remove forward motion from evil motion ma
    (define-key evil-motion-state-map " " nil)

    (define-key evil-normal-state-map (kbd "g t") 'js-jump-to-implementation-or-test)

    ;;map control s p to finding a file with projectile
    (global-set-key (kbd "C-S-p") 'projectile-find-file)

    ;;have j and k go down to next visual line
    (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)

    (global-set-key (kbd "C-c C-n") 'create-new-empty-buffer)
    (global-set-key (kbd "C-c C-o") 'just-my-main-window)
    (define-key org-mode-map (kbd "C-c C-o") 'just-my-main-window)

    (global-set-key (kbd "RET") 'newline-and-indent)

    ;;Remap alt p to switching a project with projectile
    (global-set-key (kbd "M-p") 'projectile-switch-project)

    (global-set-key (kbd "C-h") 'previous-buffer)
    (global-set-key (kbd "C-l") 'next-buffer)
    (global-set-key (kbd "C-S-h") 'winner-undo)
    (global-set-key (kbd "C-S-l") 'winner-redo)
    (global-set-key (kbd "C-c C-q") 'kill-this-buffer)

    (global-set-key (kbd "C-S-m") 'mc/mark-all-like-this-dwim)
    (map-n-v-evil-states (kbd "SPC m") 'mc/mark-next-like-this)
    (define-key mc/keymap (kbd "C-n") 'mc/mark-next-like-this)
    (define-key mc/keymap (kbd "C-S-n") 'mc/skip-to-next-like-this)
    (define-key mc/keymap (kbd "C-p") 'mc/unmark-next-like-this)
    (define-key mc/keymap (kbd "C-S-p") 'mc/unmark-previous-like-this)

    (global-set-key (kbd "C-S-SPC") 'er/contract-region)
    (global-set-key (kbd "C-SPC") 'er/expand-region)

    (map-n-v-evil-states (kbd "SPC j") 'evil-ace-jump-two-chars-mode)
    (map-n-v-evil-states (kbd "SPC r") 'js2r-rename-var)
    (map-n-v-evil-states (kbd "SPC l") 'js2r-log-this)
    (map-n-v-evil-states (kbd "SPC c") 'evilnc-comment-or-uncomment-lines)
    (map-n-v-evil-states (kbd "SPC p") 'projectile-find-file)

    (global-set-key (kbd "C-s") 'save-buffer)
    (map-n-v-evil-states (kbd "SPC s") 'save-buffer)

    (define-key evil-normal-state-map (kbd "gp") 'evil-select-last-yanked-text)

    (setq evil-default-state `normal)
    (evil-define-key `normal org-src-mode-map (kbd "SPC '") 'org-edit-src-save-and-exit)
    (evil-define-key `normal org-src-mode-map (kbd "SPC s") 'org-edit-src-save)
    (define-key org-src-mode-map (kbd "C-s") 'org-edit-src-save)
    (evil-define-key `normal org-mode-map (kbd "SPC '") 'org-edit-special)


    (defun org-edit-src-save-and-exit()
      (interactive)
      (org-edit-src-save)
      (org-edit-src-exit 'exit))

    ;; (map-n-v-evil-states  (kbd "SPC i") 'helm-swoop)
    (global-set-key (kbd "C-S-i") 'helm-projectile-ack)

    ;; (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    ;; (require 'helm-swoop)
    ;; (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

    (map-n-v-evil-states (kbd "go") 'find-file-other-frame)
    (define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
    (define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)

    (define-key js2-mode-map (kbd "C-c C-o") nil)
    ;; (map-n-i-evil-states (kbd "C-S-k") 'move-text-up)
    ;; (map-n-i-evil-states (kbd "C-S-j") 'move-text-down)
    ;; (evil-define-key `normal js2-mode-map (kbd "C-S-k") 'js2r-move-line-up)
    ;; (evil-define-key `insert js2-mode-map (kbd "C-S-k") 'js2r-move-line-up)
    ;; (evil-define-key `normal js2-mode-map (kbd "C-S-j") 'js2r-move-line-down)
    ;; (evil-define-key `insert js2-mode-map (kbd "C-S-j") 'js2r-line-move-down)

    ;; (define-key evil-normal-state-local-map (kbd "<right>") 'hannesr/evil-normal-move-character-forward)
    ;; (define-key evil-normal-state-local-map (kbd "<left>") 'hannesr/evil-normal-move-character-backward)
    ;; (define-key evil-visual-state-local-map (kbd "<right>") 'hannesr/evil-visual-move-selection-forward)
    ;; (define-key evil-visual-state-local-map (kbd "<left>") 'hannesr/evil-visual-move-selection-backward)

  #+end_src

** TODO [#C] Clean up keyboard shortcuts
- More consistency is needed, think about appropriate prefixes.
- Ctrl p is a poor project launching shortcut (too many
  applications use it for 'previous'


* Key chords
kj is a convenient exit compared to escape
#+begin_src emacs-lisp
  (setq key-chord-two-keys-delay 0.5)
  (key-chord-define evil-insert-state-map "kj" 'evil-normal-state)
  (key-chord-mode +1)
#+end_src

* Evil
  Evil is an emulation layer for Vim ontop of emacs. It's a very faithful emulation.

** Select last yanked text
   This function will select whatever texted you pasted last (in the buffer).
   #+begin_src emacs-lisp

     (defun evil-select-last-yanked-text ()
       "uses evils markers to select the last yanked text"
       (interactive)
       (evil-goto-mark ?\[)
       (evil-visual-char)
       (evil-goto-mark ?\]))

     ;; (defun evil-yank-and-indent-text ()
     ;;   (interactive)
     ;;   (evil-paste-after)
     ;;   (evil-indent)
     ;;   (evil-goto-mark ?\[))

   #+end_src
** Escape should exit things
  Stole this from somewhere, attempts to map escape to various
  exits. It isn't perfect however, and I still need ctrl g from time
  to time.
#+begin_src emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (define-key mc/keymap [escape] 'mc/keyboard-quit)
  (global-set-key [escape] 'evil-exit-emacs-state)
#+end_src

** Miscellaneous
Evil star allows you to use the * shortcut on visually selected text.
Should be default vim behavior if you ask me.
#+begin_src emacs-lisp
  (require 'evil-visualstar)
  (global-evil-visualstar-mode t)
#+end_src


** Evil vs mutliple-cursors
Multiple cursors and evil [[https://github.com/magnars/multiple-cursors.el/issues/17][don't play well together]]. I ripped this
solution from [[https://github.com/jcpetkovich/.emacs.d][these configs]]. It disables evil while multiple-cursors
is running. This allows js2-refactor to still work nicely for me.
I can still use multiple cursors too, but it's less awesome without
vim keybindings.

  #+begin_src emacs-lisp
    (defun user-utils/evil-visual-or-normal-p ()
      "True if evil mode is enabled, and we are in normal or visual mode."
      (and (bound-and-true-p evil-mode)
           (not (memq evil-state '(insert emacs)))))

    (defun mc-evil-compat/switch-to-emacs-state ()
      (when (user-utils/evil-visual-or-normal-p)

        (setq mc-evil-compat/evil-prev-state evil-state)

        (when (region-active-p)
          (setq mc-evil-compat/mark-was-active t))

        (let ((mark-before (mark))
              (point-before (point)))

          (evil-emacs-state 1)

          (when (or mc-evil-compat/mark-was-active (region-active-p))
            (goto-char point-before)
            (set-mark mark-before)))))

    (defun mc-evil-compat/back-to-previous-state ()
      (when mc-evil-compat/evil-prev-state
        (unwind-protect
            (case mc-evil-compat/evil-prev-state
              ((normal visual) (evil-force-normal-state))
              (t (message "Don't know how to handle previous state: %S"
                          mc-evil-compat/evil-prev-state)))
          (setq mc-evil-compat/evil-prev-state nil)
          (setq mc-evil-compat/mark-was-active nil))))

    (add-hook 'multiple-cursors-mode-enabled-hook
              'mc-evil-compat/switch-to-emacs-state)
    (add-hook 'multiple-cursors-mode-disabled-hook
              'mc-evil-compat/back-to-previous-state)

    (defun mc-evil-compat/rectangular-switch-state ()
      (if rectangular-region-mode
          (mc-evil-compat/switch-to-emacs-state)
        (setq mc-evil-compat/evil-prev-state nil)))

    ;; When running edit-lines, point will return (position + 1) as a
    ;; result of how evil deals with regions
    (defadvice mc/edit-lines (before change-point-by-1 activate)
      (when (user-utils/evil-visual-or-normal-p)
        (if (> (point) (mark))
            (goto-char (1- (point)))
          (push-mark (1- (mark))))))

    (add-hook 'rectangular-region-mode-hook 'mc-evil-compat/rectangular-switch-state)

    (defvar mc--default-cmds-to-run-once nil)
  #+end_src

* Multiple Cursors
mc's fast key expansion was getting in the way of my other shortcuts.
So Disable it.
#+begin_src emacs-lisp
  (require 'multiple-cursors)
  ;; Don't use expand-region fast keys
  (setq expand-region-fast-keys-enabled nil)
#+end_src

* Ace Jump
I thought i'd use this, I really don't.
It's cool but less functional then I expected (for my workflow)
#+begin_src emacs-lisp
  (setq ace-jump-mode-scope 'frame)
  (setq ace-jump-mode-move-keys
        (loop for i from ?a to ?z collect i))

  (require 'ace-jump-mode)
  (defun evil-ace-jump-two-chars-mode (query-char query-char-2)
    "evil AceJump two chars mode"
    (interactive (list (read-char "First Char:")
                       (read-char "Second:")))

    (if (eq (ace-jump-char-category query-char) 'other)
      (error "[AceJump] Non-printable character"))

    ;; others : digit , alpha, punc
    (setq ace-jump-query-char query-char)
    (setq ace-jump-current-mode 'evil-ace-jump-char-mode)
    (ace-jump-do (regexp-quote (concat (char-to-string query-char)
                                       (char-to-string query-char-2)))))
#+end_src

* DONE helm swoop
helm swoop config and shortcuts. I use this mainly for current buffer searches.
CLOSED: [2015-02-11 Wed 14:05]
#+begin_src emacs-lisp
  (use-package helm-swoop
    :load-path "~/.emacs.d/vendor/helm-swoop"
    :config
    (setq
     helm-swoop-pre-input-function (lambda () "empty unless in visual mode"
                                     (if (evil-visual-state-p)
                                         (thing-at-point 'symbol)
                                       ""))
     helm-swoop-speed-or-color t)
    (map-n-v-evil-states  (kbd "SPC i") 'helm-swoop)
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
#+end_src

* wgrep-ag
Still playing with this. Haven't used it enough times to figure out how it /should/ be.
#+begin_src emacs-lisp
  (use-package wgrep
    :load-path "~/.emacs.d/vendor/Emacs-wgrep"
    :config
    (progn
      (use-package wgrep-helm)
      (use-package wgrep-ack)
      ;; (use-package wgrep-ag)

      ;; (use-package helm-ag
      ;;   :ensure t
      ;;   :load-path "~/.emacs.d/vendor/emacs-helm-ag"
      ;;   :config
      ;;   (define-key helm-ag-map (kbd "C-c C-s") 'helm-grep-save-results))
      ;; )
      ))

#+end_src
#
* Drag Stuff
Useful to drag lines up and down.
#+begin_src emacs-lisp
  (use-package drag-stuff
      :load-path "~/.emacs.d/vendor/drag-stuff.el"
      :bind
      (("C-S-j" . drag-stuff-down)
       ("C-S-k" . drag-stuff-up))
      :config
      (drag-stuff-mode t))
#+end_src
** TODO [#C] Evil compatibility improvements
- [ ] visual line mode is broken.
- [ ] being able to move rectangular regions would be nice

* Erc
I use erc for chatting with bitlbee. Still getting the hang of it.
#+begin_src emacs-lisp
  (setq erc-auto-query 'frame
        erc-query-display 'frame

        erc-interpret-mirc-color t

        erc-hide-list '("JOIN" "PART" "QUIT")

        erc-kill-buffer-on-part t
        erc-kill-queries-on-quit t
        erc-kill-server-buffer-on-quit t)


  (evil-define-key `normal erc-mode-map (kbd "RET") 'erc-send-current-line)
  (evil-define-key `visual erc-mode-map (kbd "RET") 'erc-send-current-line)

#+end_src

Automatically put us into flyspell-mode when using erc
#+begin_src emacs-lisp
  (add-hook 'erc-mode-hook 'flyspell-mode)
#+end_src

* Aggressive indent
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config
    (progn
      (global-aggressive-indent-mode t)
      ))
#+end_src

* Relative line numbers
Some customizations that allow relative line numbers to be described as
alternating letters. This way I can jump to those lines via shortcut. This
has replace ace-jump-line for me since I don't have to wait for feedback.

#+begin_src emacs-lisp
  (use-package stripe-buffer
    :load-path "~/.emacs.d/vendor/stripe-buffer"
    :config
    (progn
      (add-hook 'prog-mode-hook 'stripe-buffer-mode)
      (add-hook 'org-mode-hook 'stripe-buffer-mode)
      ))


  (use-package relative-line-numbers
    :ensure
    :config
    (progn
      (defun relative-jump-chars-list ()
        (list
         ?f ?d ?s ?a ?v
         ?t ?b ?c ?e ?g
         ?u ?h ?i ?y ?j
         ?k ?l ?m ?n ?o
         ?p ?q ?r ?w ?x
         ?z
         ))

      (defun relative-jump-chars-permutations-default()
        (cl-mapcar
         'char-to-string
         (relative-jump-chars-list)
         ))

      (defvar relative-jump-chars-permutations
        (relative-jump-chars-permutations-default))
      (setq relative-jump-chars-permutations (relative-jump-chars-permutations-default))

      ;; (defun permutations-up-to (size elements)
      ;;   (if (= size 0)
      ;;       nil
      ;;     (append  (permutations-up-to (- size 1) elements) (permutations size elements))
      ;;     ))

      ;; (defun permutations (size elements)
      ;;   (if (= size 0)
      ;;       '(())
      ;;     (cl-mapcan (lambda (p)
      ;;                  (cl-mapcar (lambda (e)
      ;;                               (cons e p))
      ;;                             elements))
      ;;                (permutations (- size 1) elements))))

      (defun relative-jump-chars-line-format (offset)
        (let ((rel (abs offset))
              (pad 3)
              (div 2))
          (cond
           ((= rel 0)
            (let ((str (number-to-string (line-number-at-pos))))
              (if (> 3 (length str))
                  (concat " " str)
                str)))
           ((or
             (< rel pad)
             (> (mod rel div) 0)) "")
           (t (let ((char (nth
                           (/ (- rel pad) div)
                           relative-jump-chars-permutations)))
                (if char
                    (concat " " char " " )
                  ""))))))

      (defun relative-jump-chars (char)
        (let ((pad 3)
              (div 2)
              (i (cl-position
                  (char-to-string char)
                  relative-jump-chars-permutations
                  :test 'cl-equalp)))
          (+
           (* i div)
           (+ pad 1))))

      (defun relative-jump-chars-next ()
        (interactive)
        (evil-next-visual-line (relative-jump-chars (read-char)) ))

      (defun relative-jump-chars-previous()
        (interactive)
        (evil-previous-visual-line (relative-jump-chars (read-char)) ))

      (setq relative-line-numbers-format 'relative-jump-chars-line-format)
      (setq relative-line-numbers-motion-function 'forward-visible-line)
      (map-n-v-evil-states " j" 'relative-jump-chars-next)
      (map-n-v-evil-states " k" 'relative-jump-chars-previous)
      (add-hook 'prog-mode-hook 'relative-line-numbers-mode)
      (add-hook 'org-mode-hook 'relative-line-numbers-mode)
      ))

#+end_src


* Tasks
** TODO Refactor emacs configuration
- [ ] use, use-package, for more cohesion.
- [ ] transition away from prelude

** TODO [#C] Bring in node REPL mode from chromebook
- [ ] configure for es6 with 6to5
- [ ] Clean up implementation
- [ ] pull from chromebook into master
** TODO [#C] Find a way to highlight all occurrences of variable
- Do it with js2 AST http://mihai.bazon.net/projects/editing-javascript-with-emacs-js2-mode/js2-highlight-vars-mode

** TODO [#C] Fix copy and paste between emacs and clipboard
Probably evil related, since being in insert mode when doing the copy seems to work.
